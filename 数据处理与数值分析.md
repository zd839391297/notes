# 第三章 方程组求根

## 3.3 非线性方程组求根

### 3.3.1二分法

```python
# Dichotomy


def Dichotomy(a, b, delta, p):
    i = np.array([a, b])
    while abs(i[0]-i[1]) > delta:
        temp = (i[0]+i[1])/2
        if p(temp)*p(i[0]) > 0:
            i[0] = temp
        else:
            i[1] = temp
        # print(i)
    print("the result of Dichotomy is", i[0])
```

### 3.3.2简单迭代法

```python
# Iterative method


def Iterative(a, b, delta, p, method):
    i = np.array([a, b])
    while abs(i[1]-i[0]) > delta:
        i[0] = method(i[1])
        # print(i)
        i[0], i[1] = i[1], i[0]
    print("the result of Iterative is", i[1])
```

### 3.3.3 Wegstein法

```python
# Wegstein


def Wegstein(a, b, delta, p, method):
    i = np.array([a, b, 0])

    def method_we(x1, x2):
        return (x2*method(x1)-x1*method(x2))/((x2-x1)-(method(x2)-method(x1)))

    while abs(i[0]-i[1]) > delta:
        i[2] = method_we(i[0], i[1])
        # print(i)
        i[0], i[1], i[2] = i[1], i[2], i[0]
    print("the result of Wegstein method is", i[1])
```

### 3.3.4 牛顿法

```python
# Newton


def Newton(a, b, delta, p):
    i = np.array([a, b])

    def method_no(x):
        m = sp.symbols("m")
        f = p(m)
        return x-p(x)/(f.diff().evalf(subs={m: x}))

    while abs(i[0]-i[1]) > delta:
        i[0] = method_no(i[1])
        # print(i)
        i[0], i[1] = i[1], i[0]
    print("the result of Newton method is", i[1])
```

### 3.3.5 弦截法

```python
# Chord cut


def Chord(a, b, delta, p):
    i = np.array([a, b, 0])

    def method_ch(x1, x2):
        return x2-p(x2)*(x2-x1)/(p(x2)-p(x1))

    while abs(i[0]-i[1]) > delta:
        i[2] = method_ch(i[0], i[1])
        # print(i)
        i[0], i[1], i[2] = i[1], i[2], i[0]
    print("the result of Chord cut method is", i[1])

```

## 3.4 非线性方程组数值解

### 3.4.1 高斯-雅可比迭代法

迭代格式 ：

![1541587418109](1541587418109.png)

### 3.4.2 高斯 -赛德尔迭代法

迭代格式：

![1541587454654](1541587454654.png)

### 3.4.3 松弛迭代法

- 一、高斯-赛德尔迭代格式
  ![1541587539738](1541587539738.png)

- 二、加入松弛因子
 ![1541587555915](1541587555915.png)

### 3.4.4 威格斯坦法

迭代格式

![1541587900617](1541587900617.png)

![1541587930918](1541587930918.png)

### 3.4.5 牛顿-拉夫森法

牛顿-拉夫森法是牛顿法在非线性方程组中的一种推广。其基本思想与牛顿法相同，将非线性方程组逐次进行线性化处理，从而构造迭代算法。假设方程组在解X*的某个邻域内，函数f1，f2，…，fn连续且存在连续一阶偏导数，则在初值邻域上将方程组作泰勒展开，并取至一阶导数项作为线性近似。

构建函数矩阵：

![1541588469244](1541588469244.png)

![1541588476695](1541588476695.png)

![1541588490164](1541588490164.png)

构建雅可比矩阵：

![1541588230017](1541588230017.png)

解方程组：

![1541588322042](1541588322042.png)

迭代公式（取松弛因子β=1）：

![1541588269355](1541588269355.png)

# 第四章 常微分方程数值解

## 4.1 引言

### 4.1.1 一些基本概念

微分方程

- 常微分方程
- 初值和边值
- 初值问题
- 边值问题

衡量一个催化剂好坏的标准：

- 活性->反应速率和活化能（阿伦尼乌斯方程）
- 稳定性
- 成本

### 4.2.2 数值方法求解微分方程的思路

**思路：**将常微分方程及其边界条件离散化，即将常微分方程转换为差分方程，然后求在离散点上的数值解

将存在区间以一定步长h等距划分，用节点上的函数值近似模拟函数

存在的问题：

- 微分方程离散化（差分），建立递推公式
- 截断误差，误差估计
- 稳定性与收敛性

## 4.2 微分方程离散化常用方法

- 差商代导数法
- 数值积分法
- 泰勒展开法

### 4.2.1 差商代导数法

1. 等分区间

2. 采用一阶向前差商近似倒数项

3. 代回原方程

4. 欧拉公式

欧拉公式的实质：折线代替原函数曲线

### 4.2.2 数值积分法

1. 一侧写为y的导数
2. 两侧求积分
3. 用  y~i~ 代替y(x~i~)
4. 采用数值积分法求积分值，建立迭代公式
   - 梯形公式（改进的欧拉公式，实质上也是折线，但是折线斜率改为端点均值）
   - 辛普森公式（实质上也是以折线近似，折线斜率为断点与终点的加权（1-4-1）平均值）
   - 矩形公式（本质上为欧拉公式）
   - 精度：辛普森公式>梯形公式>欧拉公式
   - 显式方法：简单易用，精确度低
   - 隐式方法：复杂，精确度高

5. 预报、校正公式：在迭代中通过欧拉法给出初值，只要h足够小就能保证收敛

   先由欧拉法给出预测值，再用梯形公式进行迭代校正

### 4.2.3 泰勒展开法

1. 一侧写为y的导数
2. 将y展开成泰勒级数
3. 取近似：y(x~i+1~)=y~i~+δ~i~

## 4.3 龙格-库塔法（考四阶）

*调整折线的斜率值可以提高算法的精度*

使用函数在某些点上的值的线性组合来计算近似值（斜率）

考虑函数在若干点上的函数值的线性组合来构造近似公式，通过线性组合使得近似公式与泰勒公式的前几项尽可能重合，此为R-K方法的基本思想

近似公式为：

经典的R-K公式为4阶

### 4.3.2 二阶龙格-库塔法

在计算两次函数值的情况下，局部截断误差最高为*O(h^3^)*

### 4.3.3 三阶龙格-库塔法

### 4.3.4 四阶龙格-库塔法

### 4.3.5 说明







